<!DOCTYPE html>
<html lang="en-US"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="template-info" file-name="empty.htm" version="2022-12-01" editor="USP" />
<meta name="author" content="USP" />
<meta name="creation-date" content="2023-01-20" />
<meta name="editor" content="USP" />
<meta name="change-date" content="2023-01-23" />
<meta name="version" content="1" />
<meta name="categories" content="Projects > JavaScript" />
<meta name="tags" content="project, JavaScript, HTML, spreadsheet, library" />
<meta name="description" content="JS-SpreadSheet is a super-lightweight JavaScript library that implements spreadsheet functionality in combination with an HTML table element." />

<link rel="icon" type="image/png" href="/favicon.png" sizes="16x16" />
<link rel="stylesheet" href="/inc/page.css" />
<link rel="stylesheet" href="/site.css" />
 
<title>Projects - JS-SpreadSheet</title>

</head><body><header id="page-header"><object data="title.svg" type="image/svg+xml"></object></header><div id="main-toolbar"></div><main id="page-content">

<h1>JS-SpreadSheet</h1>

<p id="page-abstract"></p>

<h2 cbc>Core Concept</h2><div>

<p>The core idea is to implement spreadsheet functionality based on the HTML <tt>table</tt> element. It has all necessary presentation features, such as grid lines, rows and columns, header and data cells, and supports fixed row and column headers. Cells can span multiple rows and/or columns. Cells content can be made editable or read-only.</p>

<p>Calculated cells are implemented with JavaScript based on the <tt>eval()</tt> function.</p>

<div class="note">Eval() is evil, never use eval()!!!<br/>Well, is it really? Firstly, if the user is an attacker, then every attack possible with eval is also possible without eval.<br/>Secondly, eval by itself is not "dangerous" &ndash; malicious input to eval() is. From the MDN: "If you run eval() with a string that could be affected by a malicious party, you may end up running malicious code..."<br/>
That's the point. In the spreadsheet library, eval() is fed with the content of <tt>eqn</tt> attributes of <tt>TD</tt> elements, which is not accessible by a malicious third party.
</div>

<!-- jh2 --></div>

<h2 cbc>Security Considerations</h2><div>



<!--h2--></div>

<h2 cbc>Row and Column Numbering</h2><div>

<p>Worksheet rows and columns are logically numbered, starting from 0. Cell(0,0) is the first cell in the upper left corner.</p>

<table class="flat-borders"><tbody><tr>
	<td>0,0</td>
	<td>0,1</td>
	<td>0,2</td>
	<td>0,3</td>
</tr><tr>
	<td>1,0</td>
	<td>1,1</td>
	<td>1,2</td>
	<td>1,3</td>
</tr><tr>
	<td>2,0</td>
	<td>2,1</td>
	<td>2,2</td>
	<td>2,3</td>
</tr></tbody></table>

<p>Usually logial cell coordinates correspond to the physical row and cell indices in the <tt>table.rows</tt> and <tt>row.cells</tt> arrays. For example, cell(1,2)  is addressed in code with <tt>table.rows[ 1 ].cells[ 2 ].</tt>. But cells can span multiple rows and/or columns. This has the effect that some <tt>row.cells</tt> arrays can have <em>fewer</em> cells than table columns:</p>

<table class="flat-borders"><tbody><tr>
	<td>0,0</td>
	<td>0,1</td>
	<td>0,2</td>
	<td>0,3</td>
</tr><tr>
	<td>1,0</td>
	<td rowspan="2" colspan="2">1,1</td>
	<td>1,3</td>
</tr><tr>
	<td>2,0</td>
	<td>2,3</td>
</tr><tr>
	<td>3,0</td>
	<td>3,1</td>
	<td>3,2</td>
	<td>3,3</td>
</tr></tbody></table>

<p>As a result, locial cell column numbers will <em>differ</em> from physical cell index values. In the example above, <tt>rows[ 1 ].cells</tt> has only three elements, <tt>rows[ 2 ].cells</tt> has only two elements. The logical cell(1,3) is accessed with <tt>table.rows[ 1 ].cells[ 2 ]</tt>, and cell(2,3) is accessed in code with <tt>table.rows[ 2 ].cells[ 1 ]</tt>.</p>

<p>Also note that row indices are not affected. Rows are always present, cells may not.</p>

<p>A spreadsheet may have row and column labels. They are implemented with regular HTML table cells, but they don't affect the logical numbering of workarea cells. As a result, programmatic row and cell index values will differ by 1 from locigal row and column numbers.</p>

<table class="flat-borders"><thead><tr style="background-color:#EEE">
	<th></th>
	<th>0</th>
	<th>1</th>
	<th>2</th>
	<th>3</th>
</tr></thead><tbody><tr>
	<th style="background-color:#EEE">0</th>
	<td>0,0</td>
	<td>0,1</td>
	<td>0,2</td>
	<td>0,3</td>
</tr><tr>
	<th style="background-color:#EEE">1</th>
	<td>1,0</td>
	<td>1,1</td>
	<td>1,2</td>
	<td>1,3</td>
</tr><tr>
	<th style="background-color:#EEE">2</th>
	<td>2,0</td>
	<td>2,1</td>
	<td>2,2</td>
	<td>2,3</td>
</tr></tbody></table>

<p>Formulas in the spreadsheet always use logial row and column numbers to address cells, because they don't change when a label row or column is added or removed. Additionally, this logical numbering is what we are used to from existing popular spreadsheet applications.</p>

<p>To make logical addressing possible, the <tt>initSpreadsheet</tt> method calculates logical row and column numbers and stores them in <tt>row.dataset.row</tt> and <tt>cell.dataset.col</tt> fields. Note that these <tt>dataset</tt> members reflect the <tt>data-row</tt> and <tt>data-col</tt> HTML element attributes, they are visible in the DOM inspector in the browser developer tools.</p>

<!--h2--></div>

<h2 cbc>Cell Input and Expressions</h2><div>

<p>The following HTML code shows user input fields and a computed cell with an <tt>xpr</tt> attribute:</p>

<figcaption class="listing">Spreadsheet table with a comuted cell</figcaption>
<pre>
&lt;table class="flat-borders"&gt;&lt;thead&gt;&lt;tr&gt;
    &lt;th colspan="2"&gt;Equation Demo&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;
    &lt;th&gt;A&lt;/th&gt;
    &lt;td <hi>contenteditable</hi>&gt;12&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;
    &lt;th&gt;B&lt;/th&gt;
    &lt;td <hi>contenteditable</hi>&gt;34&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;
    &lt;th&gt;Sum&lt;/th&gt;
    &lt;td <hi>xpr</hi>="cell(-2,0)+cell(-1,0)"&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
</pre>

<p>Whenever the input cell value is changed, the result cell is updated. Effectively, it should work as in the following example:</p>

<figcaption class="table">Spreadsheet input study</figcaption>
<table id="table-01" class="spreadsheet flat-borders"><thead><tr>
	<th colspan="2">Equation Demo</th>
</tr></thead><tbody><tr>
	<th>A</th>
	<td contenteditable>12</td>
</tr><tr>
	<th>B</th>
	<td contenteditable>34</td>
</tr><tr>
	<th>Sum</th>
	<td equation="cell(-2,0)+cell(-1,0)">46</td>
</tr></tbody></table>

<script>
( function ( ) {
	// const spreadsheets = document.getElementsByClassName( "spreadsheet" );
	const spreadsheets = [ document.getElementById( "table-01" ) ];
	for ( let i = 0 ; i < spreadsheets.length ; i ++ ) {
		spreadsheets[ i ].addEventListener( "input", function ( evt ) {
			console.log( "Input!" );
			this.rows[ 3 ].cells[ 1 ].innerText = parseInt( this.rows[ 1 ].cells[ 1 ].innerText ) + parseInt( this.rows[ 2 ].cells[ 1 ].innerText );
		}	)	;	}
	} ) ( ) ;
</script>

<p>Although, the computation has been faked here with a hard-coded instruction rather than the evaluation of an equation. Here is the code:</p>

<figcaption class="listing">Processing input events</figcaption>
<pre>
<cc>// Find the spreadsheet tables</cc>
const spreadsheets = document.getElementsByClassName( "spreadsheet" );
for ( let i = 0 ; i &lt; spreadsheets.length ; i ++ ) {
    <cc>// Add input event handlers</cc>
    spreadsheets[ i ].addEventListener( "input", function ( evt ) {
        <cc>// Input event: Calculate the new sum and update the result cell</cc>
        this.rows[ 3 ].cells[ 1 ].innerText = parseInt( this.rows[ 1 ].cells[ 1 ].innerText ) + parseInt( this.rows[ 2 ].cells[ 1 ].innerText );
    }   ) ; }
</pre>

<p>The <tt>input</tt> event fires with every keystroke. The eventhandler performs the computation and updates the result cell. In reality, all equations of a spreadsheet must be evaluated. Or at least all equations that directly or indirectly reference the modified input cell. In a complex worksheet, this might take a considerable amount of time. </p>

<p>The <tt>change</tt> event occurs when the cell value is commited by pressing enter or when the input element looses focus. Unfortunately, this event is not fired by the <tt>td</tt> elements, so we will have to resort to a different stragety: A timeout event can be registered that updates the spreadsheet table after a short while of input inactivity.</p>

<!-- h2 --></div>

<h2 cbc>Equation Syntax</h2><div>



<!-- h2 --></div>

<h2 cbc>Preparing Equations for Evaluation</h2><div>

<p>A computed cell has a formula associated, like this:</p>

<figcaption class="listing">A calculated field</figcaption>
<pre>
&lt;td equation="2 * (cell(-2,0) + cell(-1,0))"
</pre>

<p>This formula addresses cells in the two rows above the current cell, same column. This is relative addressing, the parameters of the cell function are considered <em>offset values</em>. This </p>

<figcaption class="listing">A calculated field</figcaption>
<pre>
&lt;td equation="2 * (cell($0$1) + cell($1$1))"
</pre>

<p>The equation accesses cells in row 0, column 1 and row 1, column 0. Thi</p>

<!-- h2 --></div>

<h2 cbc>Maintaining Cell References</h2><div>

<p>Whenever rows or columns are inserted or deleted, cell references in equations will be broken. Without countermeasures, a spreadsheet will be rather useless. In this section we will develop a strategy how cell references can be maintained and kept valid.</p>

<p>Observations:</p>

<p>1.  If we insert a row (column), references that go across this new row (column), are broken.</p>

<!-- h2 --></div>

</main><footer id="page-footer"></footer><script type="module" src="/inc/page.js" ></script></body></html>